<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>得瑟侯</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://desehou.me/"/>
  <updated>2016-07-29T01:57:53.000Z</updated>
  <id>http://desehou.me/</id>
  
  <author>
    <name>Desehou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用的本地保存数据的几种方式</title>
    <link href="http://desehou.me/2016/07/29/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://desehou.me/2016/07/29/常用的本地保存数据的几种方式/</id>
    <published>2016-07-29T01:53:05.000Z</published>
    <updated>2016-07-29T01:57:53.000Z</updated>
    
    <content type="html">&lt;p&gt;在iOS开发过程中，不管是做什么应用，都会碰到数据保存的问题。将数据保存到本地，能够让程序的运行更加流畅，节省用户流量，减少不必要的网络请求，使得用户体验更好。下面介绍一下数据保存的方式：&lt;br&gt;1.NSKeyedArchiver：采用归档的形式来保存数据，该数据对象需要遵守NSCoding协议，并且该对象对应的类必须提供encodeWithCoder:和initWithCoder:方法。前一个方法告诉系统怎么对对象进行编码，而后一个方法则是告诉系统怎么对对象进行解码。例如对Possession对象归档保存。&lt;br&gt;定义Possession：&lt;br&gt;@interface Possession：NSObject&lt;nscoding&gt;{//遵守NSCoding协议&lt;br&gt;NSString &lt;em&gt;name;//待归档类型&lt;br&gt;}&lt;br&gt;@implementation Possession&lt;br&gt;-(void)encodeWithCoder:(NSCoder &lt;/em&gt;)aCoder{&lt;br&gt;[aCoder encodeObject:name forKey:@”name”];&lt;br&gt;}&lt;br&gt;-(void)initWithCoder:(NSCoder *)aDecoder{&lt;br&gt;name=[[aDeCoder decodeObjectforKey:@”name”] retain];&lt;br&gt;}&lt;br&gt;归档操作：&lt;br&gt;如果对Possession对象allPossession归档保存，只需要NSCoder子类NSKeyedArchiver的方法archiveRootObject:toFile: 即可。&lt;/nscoding&gt;&lt;/p&gt;
&lt;p&gt;NSString *path = [self possessionArchivePath];&lt;br&gt;[NSKeyedArchiver archiveRootObject:allPossessions toFile: path ]&lt;br&gt;解压操作：&lt;/p&gt;
&lt;p&gt;同样调用NSCoder子类NSKeyedArchiver的方法unarchiveRootObject:toFile: 即可&lt;br&gt;allPossessions = [[NSKeyedUnarchiver unarchiveObjectWithFile:path] retain];&lt;/p&gt;
&lt;p&gt;缺点：归档的形式来保存数据，只能一次性归档保存以及一次性解压。所以只能针对小量数据，而且对数据操作比较笨拙，即如果想改动数据的某一小部分，还是需要解压整个数据或者归档整个数据。&lt;br&gt;2.NSUserDefaults：用来保存应用程序设置和属性、用户保存的数据。用户再次打开程序或开机后这些数据仍然存在。NSUserDefaults可以存储的数据类型包括：NSData、NSString、NSNumber、NSDate、NSArray、NSDictionary。如果要存储其他类型，则需要转换为前面的类型，才能用NSUserDefaults存储。具体实现为：&lt;br&gt;保存数据：&lt;br&gt;NSUserDefaults &lt;em&gt;defaults =[NSUserDefaults standardUserDefaults];&lt;br&gt;NSString &lt;/em&gt;name =@”default string“;&lt;br&gt;[defaults setObject:firstName forKey:@”name”];&lt;br&gt;//获得UIImage实例&lt;/p&gt;
&lt;p&gt;UIImage *image=[[UIImage alloc]initWithContentsOfFile:@”photo.jpg”];&lt;/p&gt;
&lt;p&gt;NSData *imageData = UIImageJPEGRepresentation(image, 100);//UIImage对象转换成NSData&lt;/p&gt;
&lt;p&gt;[defaults synchronize];//用synchronize方法把数据持久化到standardUserDefaults数据库&lt;br&gt;读取数据：&lt;/p&gt;
&lt;p&gt;NSUserDefaults &lt;em&gt;defaults =[NSUserDefaults standardUserDefaults];&lt;br&gt;NSString &lt;/em&gt;name = [defaults objectForKey:@”name”];//根据键值取出name&lt;br&gt;NSData &lt;em&gt;imageData = [defaults dataForKey:@”image”];&lt;br&gt;UIImage &lt;/em&gt;Image = [UIImage imageWithData:imageData];//NSData转换为UIImage&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Write写入方式：永久保存在磁盘中。具体方法为：&lt;br&gt;第一步：获得文件即将保存的路径：&lt;br&gt;NSArray &lt;em&gt;documentPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,  NSUserDomainMask,YES);//使用C函数NSSearchPathForDirectoriesInDomains来获得沙盒中目录的全路径。该函数有三个参数，目录类型、he domain mask、布尔值。其中布尔值表示是否需要通过～扩展路径。而且第一个参数是不变的，即为NSSearchPathDirectory 。在IOS中后两个参数也是不变的，即为：NSUserDomainMask 和 YES。&lt;br&gt;NSString &lt;/em&gt;ourDocumentPath =[documentPaths objectAtIndex:0];&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还有一种方法是使用NSHomeDirectory函数获得sandbox的路径。具体的用法为：&lt;/p&gt;
&lt;p&gt;NSString &lt;em&gt;sandboxPath = NSHomeDirectory();&lt;br&gt;// Once you have the full sandbox path, you can create a path from it，但是不能在sandbox的本文件层上写文件也不能创建目录，而应该是此基础上创建一个新的可写的目录，例如Documents,Library或者temp。&lt;br&gt;NSString &lt;/em&gt;documentPath = [sandboxPath&lt;br&gt;stringByAppendingPathComponent:@”Documents”];//将Documents添加到sandbox路径上，具体原因前面分析了！&lt;br&gt;这两者的区别就是：使用NSSearchPathForDirectoriesInDomains比在NSHomeDirectory后面添加Document更加安全。因为该文件目录可能在未来发送的系统上发生改变。&lt;/p&gt;
&lt;p&gt;第二步：生成在该路径下的文件：&lt;br&gt;NSString *FileName=[documentDirectory stringByAppendingPathComponent:fileName];//fileName就是保存文件的文件名&lt;br&gt;第三步：往文件中写入数据：&lt;br&gt;[data writeToFile:FileName atomically:YES];//将NSData类型对象data写入文件，文件名为FileName&lt;/p&gt;
&lt;p&gt;最后：从文件中读出数据：&lt;/p&gt;
&lt;p&gt;NSData data=[NSData dataWithContentsOfFile:FileName options:0 error:NULL];//从FileName中读取出数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SQLite：采用SQLite数据库来存储数据。SQLite作为一中小型数据库，应用ios中，跟前三种保存方式相比，相对比较复杂一些。还是一步步来吧！&lt;br&gt;第一步：需要添加SQLite相关的库以及头文件：在项目文件的Build Phases下，找到Link Binary Library(ies)，添加libsqlite3.0.dylib（libsqlite3.dylib与前者的区别暂时不知，两者应该差不多）；在项目文件中头文件或者源文件中添加头文件#import “/usr/include/sqlite3.h”&lt;br&gt;第二步：开始使用SQLite：&lt;br&gt;NSArray &lt;em&gt;documentsPaths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask , YES);&lt;br&gt;NSString &lt;/em&gt;databaseFilePath=[[documentsPaths objectAtIndex:0] stringByAppendingPathComponent:@”mydb”];&lt;br&gt;//上面两句已经比较熟悉了吧！&lt;br&gt;//打开数据库&lt;br&gt;if (sqlite3_open([databaseFilePath UTF8String], &amp;amp;database)==SQLITE_OK) {&lt;br&gt;NSLog(@”sqlite dadabase is opened.”);&lt;br&gt;}&lt;br&gt;else{ return;}//打开不成功就返回&lt;br&gt;在打开了数据库的前提下，如果数据库没有表，那就开始建表了哦！&lt;br&gt;char &lt;em&gt;error;&lt;br&gt;const char &lt;/em&gt;createSql=”create table(id integer primary key autoincrement, name text)”;&lt;br&gt;if (sqlite3_exec(database, createSql, NULL, NULL, &amp;amp;error)==SQLITE_OK) {&lt;br&gt;NSLog(@”create table is ok.”);&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;NSLog(@”error: %s”,error);&lt;br&gt;sqlite3_free(error);//每次使用完毕清空error字符串，提供给下一次使用&lt;br&gt;}&lt;br&gt;建表完成之后，就开始插入记录：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;const char *insertSql=”insert into a person (name) values(‘gg’)”;&lt;br&gt;if (sqlite3_exec(database, insertSql, NULL, NULL, &amp;amp;error)==SQLITE_OK) {&lt;br&gt;NSLog(@”insert operation is ok.”);&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;else&lt;br&gt;{&lt;br&gt;NSLog(@”error: %s”,error);&lt;br&gt;sqlite3_free(error);//每次使用完毕清空error字符串，提供给下一次使用&lt;br&gt;}&lt;br&gt;下一步，查询记录：&lt;/p&gt;
&lt;p&gt;const char &lt;em&gt;selectSql=”select id,name from a person”;&lt;br&gt;sqlite3_stmt &lt;/em&gt;statement;&lt;br&gt;if (sqlite3_prepare_v2(database,selectSql, -1, &amp;amp;statement, nil)==SQLITE_OK) {&lt;br&gt;NSLog(@”select operation is ok.”);&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;NSLog(@”error: %s”,error);&lt;br&gt;sqlite3_free(error);&lt;br&gt;}&lt;br&gt;while(sqlite3_step(statement)==SQLITE_ROW) {&lt;br&gt;int _id=sqlite3_column_int(statement, 0);&lt;br&gt;NSString &lt;em&gt;name=(char&lt;/em&gt;)sqlite3_column_text(statement, 1);&lt;br&gt;NSLog(@”row&amp;gt;&amp;gt;id %i, name %s”,_id,name);&lt;br&gt;}&lt;br&gt;sqlite3_finalize(statement);&lt;/p&gt;
&lt;p&gt;最后，关闭数据库：&lt;/p&gt;
&lt;p&gt;sqlite3_close(database);&lt;br&gt;注意：写入数据库，字符串可以采用char方式，而从数据库中取出char类型，当char类型有表示中文字符时，会出现乱码。这是因为数据库默认使用ascII编码方式。所以要想正确从数据库中取出中文，需要用NSString来接收从数据库取出的字符串。&lt;br&gt;   我最喜欢用的是NSUserDefaults和本地文件Plist方式，用NSUserDefaults来存储一些加密过的用户信息，比如账号密码啥的，用Plist来存储一些用户收藏的信息等一些暂时需要缓存的数据。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发过程中，不管是做什么应用，都会碰到数据保存的问题。将数据保存到本地，能够让程序的运行更加流畅，节省用户流量，减少不必要的网络请求，使得用户体验更好。下面介绍一下数据保存的方式：&lt;br&gt;1.NSKeyedArchiver：采用归档的形式来保存数据，该数据对象需要遵
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx接口数据返回的坑</title>
    <link href="http://desehou.me/2016/07/08/nginx%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E7%9A%84%E5%9D%91/"/>
    <id>http://desehou.me/2016/07/08/nginx接口数据返回的坑/</id>
    <published>2016-07-08T01:36:54.000Z</published>
    <updated>2016-07-08T03:15:41.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;项目开发结束，按照计划上了预演环境，测试部的小伙伴在测试中发现有一个功能返回数据出错，android版本和iOS版本一样。项目上线在即怎么出了这样的问题，我们app开发的小伙伴首先怀疑是服务端接口有问题，服务端小伙伴用浏览器工具调试发现接口正常，并且该接口是post方式，长度应该绝对够用的。经过断点排查发现，返回是有数据的，但是数据是非正常的json格式，被截断了。
  是被谁截断了呢？
  我开始怀疑是afnetworking框架截断了，网上查了一通，也没找到原因。偶然在打断点的过程中看到了nginx字样，瞬间怀疑nginx截断了数据。google一下发现大量数据过长被nginx截断的文章。
  fastcgi_buffers      8 4K;
  fastcgi_buffer_size  4K;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fastcgi_buffers 控制 nginx 最多创建 8 个大小为 4K 的缓冲区，而 fastcgi_buffer_size 则是处理 Response 时第一个缓冲区的大小，不包含在前者中。所以总计能创建的最大内存缓冲区大小是 8&lt;em&gt;4K+4K = 36k。而这些缓冲区是根据实际的 Response 大小动态生成的，并不是一次性创建的。比如一个 8K 的页面，Nginx 会创建 2&lt;/em&gt;4K 共 2 个 buffers。&lt;/p&gt;
&lt;p&gt;当 Response 小于等于 36k 时，所有数据当然全部在内存中处理。如果 Response 大于 36k 呢？fastcgi_temp 的作用就在于此。多出来的数据会被临时写入到文件中，放在这个目录下面。&lt;/p&gt;
&lt;p&gt;内存中缓冲了 36Kb，剩下的会写入的文件中。而实际的情况是，运行 Nginx Process 的用户并没有 fastcgi_temp 目录的写权限，于是剩下的数据就丢失掉了。&lt;br&gt;   所以nginx要给这个目录的读写权限，并且将nginx改为root用户。&lt;br&gt;   重新请求正常。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;项目开发结束，按照计划上了预演环境，测试部的小伙伴在测试中发现有一个功能返回数据出错，android版本和iOS版本一样。项目上线在即怎么出了这样的问题，我们app开发的小伙伴首先怀疑是服务端接口有问题，服务端小伙伴用浏览器工具调试发现接口正常，并且该接口是
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo博客搭建遇到的坑</title>
    <link href="http://desehou.me/2016/07/07/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://desehou.me/2016/07/07/hexo博客搭建遇到的坑/</id>
    <published>2016-07-07T07:42:15.000Z</published>
    <updated>2016-07-07T08:03:28.000Z</updated>
    
    <content type="html">&lt;p&gt;   之前自己的博客在CSDN，已经好久没有更新维护，最近项目告一段落，打算在github上搭建一个技术博客，查了很多资料，选中了hexo，经过一下午的折腾终于成功，第一篇文章就总结下自己搭建hexo过程中遇到的坑吧。&lt;/p&gt;
&lt;p&gt;坑1：hexo不能push到github上&lt;br&gt;    hexo安装资料：&lt;br&gt;    &lt;a href=&quot;http://www.jianshu.com/p/465830080ea9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/465830080ea9&lt;/a&gt;&lt;br&gt;    自己按照上述资料安装，发现死活不能deploy到github，折腾了好久，甚至重新删除安装还是不行，后来发现原因，原来是type参数和值中间必须要有空格，而那个教程中却是没有空格的，并且hexo的官方文档里着重强调必须要注意空格问题。看来是自己不仔细看官方文档的后果。&lt;br&gt;     type: git&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;repo: https://github.com/leopardpan/leopardpan.github.io.git

branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;坑2：注意站点_config.yml和theme _config.yml&lt;br&gt;    hexo部署成功，自己感觉主题太丑了，想换个主题，换了主题之后不管自己如何设置头像就是不能设置成功，后来发现原因，有的主题换头像实在站点的_config.yml中添加avatar字段和头像地址，而有的头像则是在主题目录下的_config.yml中进行配置，这点一定要注意，仔细查看所用主题的文档说明。&lt;br&gt;坑3: 自己的域名指向github.io不成功&lt;br&gt;     自己在修改过_config.yml之后，会执行hexo c，hexo g,hexo d命令，导致原本在github上的CNAME文件被删除，域名指向不成功。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;   之前自己的博客在CSDN，已经好久没有更新维护，最近项目告一段落，打算在github上搭建一个技术博客，查了很多资料，选中了hexo，经过一下午的折腾终于成功，第一篇文章就总结下自己搭建hexo过程中遇到的坑吧。&lt;/p&gt;
&lt;p&gt;坑1：hexo不能push到github
    
    </summary>
    
    
  </entry>
  
</feed>
